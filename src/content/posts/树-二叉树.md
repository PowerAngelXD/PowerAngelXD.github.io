---
title: 树-二叉树
published: 2025-11-24
description: ''
image: ''
tags: [数据结构]
category: '算法'
draft: false 
lang: ''
---
# 二叉树
## 概论
二叉树，顾名思义，一个节点下只能最多有两个子节点：
![](img/BinaryTree/bin.png)

而它在C++的实现一般是这样的：
```c++
struct BinaryNode {
    int val;
    BinaryNode* left = nullptr;
    BinaryNode* right = nullptr;

    BinaryNode(int v): val(v) {}
};
```
一个二叉树的节点，其内存在两个指向节点的指针：`left` 和`right`，用于代指两边的节点
## 二叉树的一个应用：二元表达式解析
事实上，二叉树在解析二元表达式上有很大的优势，在表达式树中，树叶为**操作数**，而其它节点则为**操作符**，如下图例子所示
![](img/BinaryTree/exprTree.png)

而为了能够很好的解析这样的二元表达式，我们将使用中缀表达式（逆波兰表达式）来进行这样的操作

### 逆波兰表达式
逆波兰表达式是一种有利于计算机进行处理的表达式表示方式，举个例子：

$$\text{1 + 2 * 3} \quad \longrightarrow \quad \mathbf{1\ 2\ 3\ * +}$$

而它的处理方式则是用栈的方式，将操作符压入栈中，再根据优先级进行判断是否出栈

让我们对上面给出的例子进行说明：

1. 从左向右扫描表达式串
2. 扫描到 `1`，加入到结果串中
3. 扫描到 `+`，操作符入栈
4. 扫描到 `2`，加入到结果串中
5. 扫描到 `*`，优先级大于 `+`，压入栈中
6. 扫描到 `3`，加入到结果串中
7. 源串结束，将栈中的操作符依次弹出并加入到结果串中

其中，对于入栈的流程，我们用下图表示：

![](img/BinaryTree/opStack.png)

最终便得到了我们的结果串：`1 2 3 * +`

同样的：

$$\text{1 + 2 + 7 * 9 - 3} \quad \longrightarrow \quad \mathbf{1\ 2\ + \ 7\ 9\ * \ + \ 3\ -}$$

### 利用逆波兰表达式构造表达式树
我们利用逆波兰表达式构造表达式树，就是要对得到的逆波兰表达式串进行扫描再构建，代码如下：
```c++
void binaryExprConstruct(std::string expr) {
    std::stack<BinaryNode<char>*> runtime;
    for (auto ch: expr) {
        if (isdigit(ch))
            runtime.push(new BinaryNode(ch));
        else {
            auto right = runtime.top(); runtime.pop();
            auto left = runtime.top(); runtime.pop();
            auto node = new BinaryNode(ch);
            node->left = left;
            node->right = right;
            runtime.push(node);
        }
    }

    runtime.top()->preorderTraversal();
}
```
需要注意的是，上述方法的参数 `expr` 是逆波兰表达式而不是我们熟知的自然表达式

在构造这样一个表达式树的时候，直接将数字压入栈中；而对于符号，弹出栈中的两个元素（必定为数字），再分别插入到新构建的 `node` 的 `left` 和 `right` 两个子节点中；最后将这个指针压入栈中即可

